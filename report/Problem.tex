%****************************************************************************
%** Copyright 2002 by Lukas Ruf, ruf@topsy.net
%** Information is provided under the terms of the
%** GNU Free Documentation License http://www.gnu.org/copyleft/fdl.html
%** Fairness: Cite the source of information, visit http://www.topsy.net
%****************************************************************************
%****************************************************************************
%** Last Modification: 2005-07-11 1600
%** 2005-07-11	Bernhard Tellenbach
%**							This is an addapted version of the Introduction.tex file
%**							Added table example (footnotes,multicolumn)
%**							Examples for different text sizes
%**							Updated eps file inclusion example for use with graphicx pkt. 
%****************************************************************************

\chapter{\label{chapter3}Motivation}

Routers using BGP can suffer from long convergence times after a remote failure. This is mainly due to the propagation delay of the updates. At an iSDX many BGP routers are present and the propagation delay is made even worse because of the additional computation the participant controller needs to do to process a BGP update. Only once the participant controller has finished processing the update can the update be sent to the border router of its participant.  \rb{In my opinion, the processing time of the participant controller does not really matter as it might only add at most a few seconds to it. However, why it is good to implement Swift at an iSDX is that with a single deployment of Swift, you can improve the convergence time of several hundred border routers. Also, not all parts of Swift have to be replicated that many times, but can be shared among all participants. Routers at IXPs are subject to long convergence times the same way as any other router in the Internet.}

When receiving a BGP update the iSDXs route server first forwards the update to the participant controllers. The participant controller updates it's RIB, checks if the policy flow rules have changed and if the Virtual Next-Hop/VMAC has changed. This additional computation adds a significant \rb{it is not significant. We are talking of convergence times of a couple of minutes. It adds at most a couple of seconds.} overhead to the time until the participants border router receives the BGP update. Which in turn impacts the convergence time of the routers connected to the iSDX.

Implementing Swift into the iSDX promises to significantly reduce the convergence time. Convergence time being the time from the failure to occur to the packets being sent to the correct participant and not into a black hole. The idea being that Swift can push fast-reroute flow rules into the SDN switch and redirect packets to a backup participants.

The main reason why implementing Swift in the iSDX is reasonable is the similarity their architecture: Both  iSDX and Swift use an SDN switch to program flow rules to steer traffic. They both are connected to BGP speaking routers and receive BGP updates from them. Swift and iSDX both use the destination mac address to encode information about a prefix and use the next-hop to map this VMAC to a prefix. In addition the Swift framework allows multiple swifted routers to be connected to the SDN switch, which in the iSDX's case means that all the participants will benefit from Swift.

\rb{this paragraph needs to be polished more. The second sentence is not a real sentence (fragment).}
The main challenge when implementing Swift into iSDX is to change as little as possible in both systems. Utilizing their similar architecture to keep the full functionality of both iSDX and Swift. At the same time also making sure that Swift does not add too much overhead to the processing of a BGP update.

In the next chapter, we explain how Swift was implemented in the iSDX. 
