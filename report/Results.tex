\chapter{\label{chapter4}Evaluation}

In this chapter we present the results of the tests we ran to evaluate the convergence performance of the iSDX. We explain the test setup in \ref{chapter4:Test Setup}. We present the convergence time of iSDX without Swift in \ref{chapter4:Convergence time without Swift}. We present the convergence performance of the iSDX with Swift in \ref{chapter4:Convergence time with Swift} and examine the Swift overhead in \ref{chapter4:Swift overhead} \\
In the next chapter we will discuss the results, examine the VMAC partitioning and the fast-reroute rules.

\section{\label{chapter4:Test Setup}Test Setup}

\begin{figure}[h]
\center
\includegraphics[scale = 0.36]{Figures/eval_exp_setup.pdf}
\caption{Test Setup}
\label{fig:test-setup}
\end{figure}

Figure~\ref{fig:test-setup} shows the test setup.
The test setup has an iSDX with or without Swift connected to three participants. Participants B1 and C1 are connected to the rest of the internet via R1 and advertise up to 500000 prefixes to A1. Participant A1 prefers routes from B1. Remote failure is simulated by setting the link B1 R1 down. If this link is down A1 needs to updates his RIB, check if flow rules have changed and update the virtual next-hop/vmac for every withdrawn prefix.\\ 
The experiment setup is run in on a server with following specs: 1x4 Cores Xeon CPU E5620 @2.4 GHz, 36G RAM, linux version 4.4.0-38-generic. The experiment is run in Mininet \cite{mininet}. The routers A1, B1, C1 and R1 are quagga \cite{quagga} routers. The perl script bgpsimple \cite{bgpsimple}is used to inject an arbitrary number of routes into R1. 



\section{\label{chapter4:Convergence time without Swift}Convergence Time without Swift}

Convergence time is measured as the time between the first withdraw arriving in the route server and the participant controller finishing to process the last withdraw. To measure the convergence time we use the built in iSDX log server.\\
This convergence time does not take into account the hold timer or the time the participant router takes to process the withdrawals. But since these things are not under the control of the iSDX they are ignored in this evaluation.

\begin{figure}[h]
\center
\includegraphics[scale = 1]{Figures/noswift.pdf}
\caption{Convergence time of the iSDX without Swift}
\label{fig:noswift}
\end{figure}

Figure~\ref{fig:noswift} shows the convergence time depending on the number of prefixes injected by bgpsimple.
The convergence time increases linearly with the number of prefixes advertised by R1. \\
At 500'000 prefixes the iSDX takes about 90 seconds to converge. During these 90 seconds A1 sends packet to B1, which then get dropped by B1. 

\section{\label{chapter4:Convergence time with Swift}Convergence Time with Swift}

Convergence time is measured as the time between the first withdraw arriving in the route server and the participant controllers FR handler finishing to push the Fast-reroute rules. \\

\begin{figure}[h]
\center
\includegraphics[scale = 1]{Figures/swift.pdf}
\caption{Convergence time of the iSDX without Swift}
\label{fig:withswift}
\end{figure}

Figure~\ref{fig:withswift} shows the convergence time depending on the number of prefixes injected by bgpsimple.
The convergence time increases slightly with higher number of prefixes. At 500'000 prefixes the iSDX takes about 1.5 seconds to push the FR rules. After these 1.5 seconds packets sent from A1 get redirected to C1 and reach their destination. \\

\section{\label{chapter4:Swift overhead}Swift overhead}

\newpage