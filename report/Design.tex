\chapter{\label{chapter4}Implementation}

In this chapter, we show how we integrated Swift into iSDX. We give an overview of the modified iSDX architecture in \ref{chapter4:Architecture}. We explain the two new modules that were added to the iSDX in \ref{chapter4:Swift-BPA} and  \ref{chapter4:FR-handler}. Then, we show how we combined the VMAC schemes of Swift and iSDX and partitioned the available bits among the two in \ref{chapter4:vmac_partitioning}. At last, we explain how the default iSDX modules had to be adapted in \ref{chapter4:Changes_to_the_iSDX}.

In the next chapter, we present the results of the tests done to measure the convergence performance of the iSDX.

\section{\label{chapter4:Architecture}Architecture}

\begin{figure}[h]
\center
\includegraphics[scale = 0.7]{Figures/design_sdx_swift_cropped.pdf}
\caption{iSDX architecture with Swift}
\label{fig:isdx_architecture_with_swift}
\end{figure}
\rb{decrease the size of the figure a bit}

Figure~\ref{fig:isdx_architecture_with_swift} shows the iSDX~\cite{feamster2013sdx} architecture with Swift. The orange modules represent the new modules we had to add to the iSDX to implement Swift. The iSDX receives two additional modules the Swift-BPA module in the central services and the FR handler in the participant controller. With these two modules the iSDX is able to detect bursts of withdrawals, predict the failed AS-link that caused the burst and push fast reroute rules into the IXP fabric.

In the following sections, we explain the functionality of the new modules and other changes to the iSDX in more detail.

\section{\label{chapter4:Swift-BPA}Swift-BPA}

\begin{figure}[h]
\center
\includegraphics[scale = 0.5]{Figures/design_swift_bpa_cropped.pdf}
\caption{pipeline of the Swift-BPA module}
\end{figure}

The Swift-BPA module implements Swifts main functionality, encoding and prediction. It is part of the central services and exchanges BGP updates and FR messages with the route server and participant controllers.

The Swift-BPA module is placed in the route server and processes each update received by the route server before passing it on to the participant controllers. 

\rb{better explain what the AS-topology is for or refer to the Background chapter if you explained it there, the same goes for the AS-path. Have you explained anywhere what FR messages are? If not, you need to do this. Else it is hard to understand what these messages are and why they would be sent. Also in the sentence afterwards, you kind of explain it, but you don't use the abbreviation consistently. you should introduce the abbreviation somewhere. You can use these FR messages to link to the next section.}
When receiving a BGP update the Swift-BPA updates the AS-topology and adds the AS-path encoding to the BGP update. Then the update gets sent to the participant controller. 
After the update is sent to the participant controller the burst detection checks if the update triggers a burst. If so the prediction module predicts the failed AS-link, the cause for the burst and sends FR messages to the participant controller. 
The fast reroute message inform the participant controllers about the AS-link that is predicted to be down. \rb{In the following, we show how the participant controller handles the FR messages.}

Similar to the participant controller every participant has a Swift-BPA process running. The Swift-BPA only receives BGP updates from his own routers. This way the Swift engine can be implemented without any modifications.

\section{\label{chapter4:FR-handler}FR-Handler}

\begin{figure}[h]
\center
\includegraphics[scale = 0.6]{Figures/design_fr_handler_cropped.pdf}
\caption{pipeline of the fast reroute handler}
\end{figure}

\rb{reorder it. start with the reception of such a FR message to link it to the previous section and then explain what is done in the FR Handler.}
The FR-handler implements the pushing of fast reroute rules.
Once the Swift-BPA predicts a failed AS-link it sends FR messages to all the participant controllers.
The FR-handler receives FR messages and computes the fast reroute rules using the backup next-hops and the predicted AS-link. Every participant controller computes its own backup next-hops. The fast reroute rules get sent to the reference monitor as flow rule messages. The reference monitor then installs the flow rules in the SDN switch. Just like in Swift the fast reroute rules match on the failed AS-link and on the backup next-hop.    

\newpage

\section{\label{chapter4:vmac_partitioning}VMAC Partitioning}

Both Swift and iSDX use the destination MAC address as a VMAC to attach additional information to the packet. It is not easy to use another field of the header as only the destination MAC address can be changed by modifying the next hop attribute. Therefore the VMAC has to be shared between the iSDX and the Swift encoding. The number of bits available to encode information for the iSDX and Swift is reduced. This is because the iSDX and Swift encode 
different information about the prefix. The iSDX encodes the participants advertising the prefix and the BGP best next hop. Swift encodes the AS-path and the backup next hops for each link on the AS-path.

The encoded AS-path starts with the second AS on the AS-path. This is because the first AS is already encoded as the BGP best next-hop. (in the iSDX part of the VMAC)

\begin{figure}[h]
\center
\includegraphics[scale = 0.24]{Figures/design_vmac_topology.pdf}
\includegraphics[scale = 0.35]{Figures/design_vmac_cropped.pdf}
\caption{example of the VMAC in the iSDX with Swift}
\end{figure}

\section{\label{chapter4:Changes_to_the_iSDX}Changes to the iSDX}

We had to apply a few changes to the iSDX's modules. These changes mainly affect the route server, the local RIB of the participant controller and the VMAC encoding. 

\paragraph{\label{chapter4:Changes to the iSDX:route server}Route Server:}

The route server had to be adapted to work with the Swift-BPA module. 
\rb{don't go into that much detail: Listener and Sender. Just write that instead of simply forwarding all the BGP updates to the participant controllers, the route server now has to notify the Swift-BPA module before forwarding the updates. Only after the Swift-BPA has finished processing the updates, they can be forwarded to the participants as the updates have to be augmented with the encoding.}
It now has two modules the Listener and Sender. \\
The Listener receives BGP updates and forwards them to the Swift-BPA. \\
The Sender receives modified BGP updates and FR messages from the Swift-BPA and forwards them to the participant controllers. The sender processes FR messages with higher priority than modified BGP updates, this way the FR messages reach the FR handlers as quickly as possible. 

\begin{figure}[h]
\center
\includegraphics[scale = 0.45]{Figures/design_route_server_cropped2.pdf}
\caption{pipeline of the modified route server}
\end{figure}


\paragraph{\label{chapter4:Changes to the iSDX:local RIB}Local RIB:}

\rb{try to link it to the previous paragraph: As each BGP update from the route server now also contains the AS-path encoding, the local RIB had to be adapted to also store this information. and so on}
The local RIB now stores the AS-path encoding. When processing a BGP update the local RIB extracts the AS-path encoding (added by the Swift-BPA) and saves it as an additional attribute. The encoded AS-path is then used in the VMAC encoding. 

\paragraph{\label{chapter4:Changes to the iSDX:Vmac Encoding}VMAC Encoding:}
\rb{try to reduce the usage of now. Here don't focus that much on what the VMAC encodes, but also that this module has to take two encodings and merge them.}
The VMAC encoding now computes the backup next-hops for the AS-path of the BGP update. There is one backup next-hop for every AS-link on the AS-path, packets can be sent to the backup next-hop in case this AS-link is predicted to be down. \\
The VMAC encoding now builds the VMAC using both iSDX and Swift encoding. \\

\newpage
